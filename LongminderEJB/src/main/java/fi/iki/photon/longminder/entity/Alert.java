package fi.iki.photon.longminder.entity;

import java.io.Serializable;

import javax.ejb.EJB;
import javax.persistence.*;

import fi.iki.photon.longminder.UserManager;
import fi.iki.photon.longminder.UserManagerBean;
import fi.iki.photon.longminder.entity.dto.AlertDTO;

import java.util.Calendar;
import java.util.Date;
import java.util.List;

/**
 * The persistent class for the ALERT database table.
 * 
 * Contains the description of the alert and the next alert date, and possibly a
 * reference to REPEAT table, where the information about repeating alarm is
 * stored.
 * 
 * Has also an OWNER field referenced/generated by data description in
 * User.java, but the reference is JPA-unidirectional.
 */
@Entity
public class Alert extends fi.iki.photon.utils.Entity implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    @Column(nullable = false, length = 128)
    private String description;

    @Temporal(TemporalType.DATE)
    @Column(nullable = false)
    private Date nextAlert;

    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "REPEAT", nullable = true)
    private Repeat repeat;

    @OneToMany(cascade = CascadeType.PERSIST)
    @JoinColumn(name = "PARENTALERT", nullable = true)
    private List<Alert> linkedAlerts;

    @Column(nullable = false)
    private boolean oneOff;

    @Column(nullable = false)
    private boolean dismissed;

    @Column(nullable = false)
    private boolean fired;

    protected Alert() {
    }

    public Alert(AlertDTO dto) {
        initialize(dto);
    }

    /**
     * Given an AlertDTO, fills the data in this Alert object by the supplied
     * values.
     * 
     * @param dto
     */

    public void initialize(AlertDTO dto) {
        setDescription(dto.getDescription());
        setNextAlert(dto.getNextAlert());
        setOneOff(dto.isOneOff());

        setFired(false);
        setDismissed(false);

        if (dto.getRepeatType() == AlertDTO.REPEAT_NO) {
            this.setRepeat(null);
        }

        if (dto.getRepeatType() == AlertDTO.REPEAT_DAY) {
            DayRepeat drep = new DayRepeat(dto);
            this.setRepeat(drep);
        }
        if (dto.getRepeatType() == AlertDTO.REPEAT_WEEK) {
            WeekRepeat wrep = new WeekRepeat(dto);
            this.setRepeat(wrep);
        }
    }

    /**
     * Given an AlertDTO object, fills its data with data from this object.
     * 
     * @param a
     */

    public void initializeDTO(AlertDTO a) {
        a.setId(getId());
        a.setDescription(getDescription());
        a.setNextAlert(getNextAlert());
        a.setOneOff(isOneOff());
        a.setFired(isFired());
        a.setDismissed(isDismissed());

        if (repeat != null) {
            repeat.initializeDTO(a);
        } else {
            a.setRepeatType(AlertDTO.REPEAT_NO);
        }
    }

    /**
     * Creates a new alert based on the repeat data, and moves the repeat data
     * to the new alert. Thus the old alert will stay in the system as a
     * non-repeating alert. Old alert will be linked to the new one, in the case
     * we want to implement a single dismiss button to the newest alert.
     * 
     * @return The newly created alert.
     */

    public Alert rotateAlert() {

        Repeat r = getRepeat();
        if (r != null) {
            Date nextRepeat = getRepeat().nextAlert(getNextAlert());
            if (r.isRepeatsLeft(nextRepeat)) {
                Alert newAlert = new Alert();
                newAlert.setDescription(getDescription());
                newAlert.setNextAlert(nextRepeat);
                newAlert.setOneOff(isOneOff());
                newAlert.setDismissed(isDismissed());

                if (r.getRepeatTimes() != null) {
                    r.setRepeatTimes(Integer.valueOf(
                            r.getRepeatTimes().intValue() - 1));
                }
                newAlert.setRepeat(r);

                List<Alert> linked = newAlert.getLinkedAlerts();
                
                linked.add(newAlert);

                setRepeat(null);

                return newAlert;
            }
            return null;
        }
        return null;
    }

    public int getId() {
        return this.id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getDescription() {
        return this.description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Date getNextAlert() {
        return this.nextAlert == null ? null : (Date) nextAlert.clone();
    }

    public void setNextAlert(Date nextAlert) {
        this.nextAlert = (nextAlert == null ? null : (Date) nextAlert.clone());
    }

    public Repeat getRepeat() {
        return repeat;
    }

    public void setRepeat(Repeat repeat) {
        this.repeat = repeat;
    }

    public boolean isOneOff() {
        return oneOff;
    }

    public void setOneOff(boolean oneOff) {
        this.oneOff = oneOff;
    }

    public List<Alert> getLinkedAlerts() {
        return linkedAlerts;
    }

    public void setLinkedAlerts(List<Alert> linkedAlerts) {
        this.linkedAlerts = linkedAlerts;
    }

    public boolean isDismissed() {
        return dismissed;
    }

    public void setDismissed(boolean dismissed) {
        this.dismissed = dismissed;
    }

    public boolean isFired() {
        return fired;
    }

    public void setFired(boolean fired) {
        this.fired = fired;
    }
}