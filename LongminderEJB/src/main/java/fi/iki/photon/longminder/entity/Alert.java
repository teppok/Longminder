package fi.iki.photon.longminder.entity;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.persistence.Access;
import javax.persistence.AccessType;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

import fi.iki.photon.longminder.entity.dto.AlertDTO;

/**
 * The persistent class for the ALERT database table.
 * 
 * Contains the description of the alert and the next alert date, and possibly a
 * reference to REPEAT table, where the information about repeating alarm is
 * stored.
 * 
 * Has also an OWNER field referenced/generated by data description in
 * User.java, but the reference is JPA-unidirectional.
 */
@Entity
@Access(AccessType.FIELD)
public class Alert extends fi.iki.photon.utils.Entity implements Serializable {
    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    @Column(nullable = false, length = 128)
    private String description;

    @Temporal(TemporalType.DATE)
    @Column(nullable = false)
    private Date nextAlert;

    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true, targetEntity = Repeat.class)
    @JoinColumn(name = "REPEAT", nullable = true)
    private Repeat repeat;

    @OneToMany(cascade = CascadeType.PERSIST, targetEntity = Alert.class)
    @JoinColumn(name = "PARENTALERT", nullable = true)
    private List<Alert> linkedAlerts;

    @Column(nullable = false)
    private boolean oneOff;

    @Column(nullable = false)
    private boolean dismissed;

    @Column(nullable = false)
    private boolean fired;

    protected Alert() {
    }

    public Alert(final AlertDTO dto) {
        initialize(dto);
    }

    /**
     * Given an AlertDTO, fills the data in this Alert object by the supplied
     * values.
     * 
     * @param dto
     */

    public void initialize(final AlertDTO dto) {
        setDescription(dto.getDescription());
        setNextAlert(dto.getNextAlert());
        setOneOff(dto.isOneOff());

        setFired(false);
        setDismissed(false);

        if (dto.getRepeatType() == AlertDTO.REPEAT_NO) {
            setRepeat(null);
        }

        if (dto.getRepeatType() == AlertDTO.REPEAT_DAY) {
            final DayRepeat drep = new DayRepeat(dto);
            setRepeat(drep);
        }
        if (dto.getRepeatType() == AlertDTO.REPEAT_WEEK) {
            final WeekRepeat wrep = new WeekRepeat(dto);
            setRepeat(wrep);
        }
    }

    /**
     * Given an AlertDTO object, fills its data with data from this object.
     * 
     * @param a
     */

    public void initializeDTO(final AlertDTO a) {
        a.setId(getId());
        a.setDescription(getDescription());
        a.setNextAlert(getNextAlert());
        a.setOneOff(isOneOff());
        a.setFired(isFired());
        a.setDismissed(isDismissed());

        if (repeat != null) {
            repeat.initializeDTO(a);
        } else {
            a.setRepeatType(AlertDTO.REPEAT_NO);
        }
    }

    /**
     * Creates a new alert based on the repeat data, and moves the repeat data
     * to the new alert. Thus the old alert will stay in the system as a
     * non-repeating alert. Old alert will be linked to the new one, in the case
     * we want to implement a single dismiss button to the newest alert.
     * 
     * @return The newly created alert.
     */

    public Alert rotateAlert() {

        final Repeat r = getRepeat();
        if (r != null) {
            final Date nextRepeat = getRepeat().nextAlert(getNextAlert());
            if (r.isRepeatsLeft(nextRepeat)) {
                final Alert newAlert = new Alert();
                newAlert.setDescription(getDescription());
                newAlert.setNextAlert(nextRepeat);
                newAlert.setOneOff(isOneOff());
                newAlert.setDismissed(isDismissed());

                if (r.getRepeatTimes() != null) {
                    r.setRepeatTimes(Integer.valueOf(r.getRepeatTimes()
                            .intValue() - 1));
                }
                newAlert.setRepeat(r);

                newAlert.addLinkedAlert(newAlert);

                setRepeat(null);

                return newAlert;
            }
            return null;
        }
        return null;
    }

    public int getId() {
        return id;
    }

    public void setId(final int id) {
        this.id = id;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(final String description) {
        this.description = description;
    }

    public Date getNextAlert() {
        return nextAlert == null ? null : (Date) nextAlert.clone();
    }

    public void setNextAlert(final Date nextAlert) {
        this.nextAlert = (nextAlert == null ? null : (Date) nextAlert.clone());
    }

    public Repeat getRepeat() {
        return repeat;
    }

    public void setRepeat(final Repeat repeat) {
        this.repeat = repeat;
    }

    public boolean isOneOff() {
        return oneOff;
    }

    public void setOneOff(final boolean oneOff) {
        this.oneOff = oneOff;
    }
/*
    public List<Alert> getLinkedAlerts() {
        return linkedAlerts;
    }

    public void setLinkedAlerts(final List<Alert> linkedAlerts) {
        this.linkedAlerts = linkedAlerts;
    }
    */

    public void addLinkedAlert(Alert linkedAlert) {
        if (linkedAlerts == null) linkedAlerts = new ArrayList<>();
        linkedAlerts.add(linkedAlert);
    }
    
    public boolean isDismissed() {
        return dismissed;
    }

    public void setDismissed(final boolean dismissed) {
        this.dismissed = dismissed;
    }

    public boolean isFired() {
        return fired;
    }

    public void setFired(final boolean fired) {
        this.fired = fired;
    }
}